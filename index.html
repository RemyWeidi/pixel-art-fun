<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Atelier Pixel Art Pro - V37 Smart Lasso Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <script>
        tailwind.config = {
            darkMode: 'class', 
            theme: {
                extend: {
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                    colors: {
                        'primary': '#06b6d4',
                        'accent-dark': '#0e7490', 
                        'soft-bg': '#f8fafc', 
                        'text-dark': '#1e293b',
                        'dark-bg': '#0f172a',
                        'dark-panel': '#1e293b',
                        'dark-border': '#334155',
                    }
                }
            }
        }
    </script>

    <style>
        /* --- BASE --- */
        body { 
            overscroll-behavior-y: none; touch-action: none; margin: 0; padding: 0; height: 100vh; overflow: hidden; 
            transition: background-color 0.3s, color 0.3s; 
        }
        /* Bloque le menu contextuel partout */
        body, #workspace { -webkit-touch-callout: none; user-select: none; -webkit-user-select: none; }

        /* --- WORKSPACE --- */
        #workspace { width: 100%; height: 100vh; background-color: #e5e7eb; position: relative; display: flex; align-items: center; justify-content: center; overflow: hidden; transition: background-color 0.3s; z-index: 0; }
        .dark #workspace { background-color: #020617; }

        #canvas-wrapper {
            position: relative; 
            background-color: white; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            flex-shrink: 0; 
            image-rendering: pixelated; 
            image-rendering: crisp-edges; 
            cursor: crosshair;
            will-change: transform;
            transform: translateZ(0); 
            backface-visibility: hidden; 
            transition: box-shadow 0.2s;
        }
        .dark #canvas-wrapper { background-color: #1e293b; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }

        .cursor-move-mode #canvas-wrapper { cursor: grab !important; }
        .cursor-move-mode #canvas-wrapper:active { cursor: grabbing !important; }
        .pipette-mode #canvas-wrapper { cursor: crosshair !important; }
        /* Curseur spécifique Lasso */
        .lasso-mode #canvas-wrapper { cursor: crosshair !important; }
        .lasso-moving #canvas-wrapper { cursor: move !important; }

        #reference-image { 
            position: absolute; inset: 0; background-size: contain; background-position: center; background-repeat: no-repeat; opacity: 0; pointer-events: none; z-index: 0; transition: opacity 0.2s; will-change: opacity; image-rendering: pixelated;
        }

        /* --- GRILLE PIXEL PERFECT --- */
        #pixel-grid { position: relative; z-index: 10; width: 100%; height: 100%; touch-action: none; display: grid; contain: strict; }
        :root { --grid-color: rgba(0,0,0,0.35); } 
        .dark { --grid-color: rgba(255,255,255,0.25); }
        #pixel-grid.show-grid {
            background-size: var(--grid-cell-px) var(--grid-cell-px);
            background-position: 0 0;
            background-image: linear-gradient(to right, var(--grid-color) 1px, transparent 1px), linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
        }
        .pixel { width: 100%; height: 100%; background-color: transparent; }

        /* --- SELECTION OVERLAY (Cadre de sélection) --- */
        #selection-overlay {
            position: absolute; border: 2px dashed #06b6d4; background: rgba(6, 182, 212, 0.15); pointer-events: none; display: none; z-index: 30; box-shadow: 0 0 0 1px white;
        }
        
        /* Feedback visuel pour les pixels en cours de déplacement */
        .pixel.preview-pixel {
            opacity: 0.8;
            box-shadow: inset 0 0 2px rgba(0,0,0,0.2);
            z-index: 25;
        }

        /* --- UI STYLES --- */
        .tool-btn { height: 48px; width: 100%; border-radius: 0.75rem; font-size: 1.1rem; background-color: white; border: 1px solid #e5e7eb; display: flex; align-items: center; justify-content: center; color: #4b5563; transition: all 0.15s; }
        .tool-btn:hover { background-color: #f9fafb; }
        .dark .tool-btn { background-color: #1e293b; border-color: #334155; color: #94a3b8; }
        .dark .tool-btn:hover { background-color: #334155; color: white; }
        .tool-active { background-color: #e0f2fe !important; border-color: #06b6d4 !important; color: #06b6d4 !important; border-width: 2px !important; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(6, 182, 212, 0.2); }
        .dark .tool-active { background-color: #164e63 !important; border-color: #22d3ee !important; color: #22d3ee !important; }

        /* Icon Only Buttons (Mirror/Grid/Lasso on Desktop) */
        .icon-btn-sm { height: 40px; width: 100%; border-radius: 0.5rem; display: flex; align-items: center; justify-content: center; border: 1px solid #e5e7eb; color: #64748b; background: white; transition: all 0.15s; }
        .dark .icon-btn-sm { background: #1e293b; border-color: #334155; color: #94a3b8; }
        .icon-btn-sm:hover { background: #f1f5f9; }
        .dark .icon-btn-sm:hover { background: #334155; color: white; }
        .icon-btn-sm.active { background-color: #06b6d4; border-color: #06b6d4; color: white; }

        .floating-actions { position: fixed; top: 16px; right: 16px; z-index: 50; display: flex; gap: 8px; }
        .float-btn { width: 44px; height: 44px; background: white; border-radius: 12px; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1); color: #4b5563; font-size: 18px; transition: background 0.3s; }
        .dark .float-btn { background: #1e293b; color: #e2e8f0; }
        .float-btn:active { transform: scale(0.95); background: #f3f4f6; }
        .dark .float-btn:active { background: #334155; }
        .float-btn:disabled { opacity: 0.5; color: #9ca3af; }

        /* --- LASSO MODAL --- */
        .lasso-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; padding: 16px; border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.25); z-index: 100;
            display: none; flex-direction: column; gap: 10px; min-width: 220px;
            border: 1px solid #e2e8f0;
        }
        .dark .lasso-modal { background: #1e293b; border-color: #334155; box-shadow: 0 10px 30px rgba(0,0,0,0.7); }

        /* --- MOBILE TOOLBAR --- */
        #swipe-toolbar {
            position: fixed; bottom: 0; left: 0; right: 0; height: 90px; 
            background: white; box-shadow: 0 -2px 10px rgba(0,0,0,0.05); 
            z-index: 150; border-top: 1px solid #f3f4f6;
            transition: background-color 0.3s; display: flex; flex-direction: column; justify-content: space-between;
        }
        .dark #swipe-toolbar { background-color: #1e293b; border-top-color: #334155; }
        .toolbar-slides { display: flex; overflow-x: auto; scroll-snap-type: x mandatory; width: 100%; height: 100%; scroll-behavior: smooth; scrollbar-width: none; }
        .toolbar-slides::-webkit-scrollbar { display: none; }
        .toolbar-slide { flex: 0 0 100%; width: 100%; scroll-snap-align: start; display: flex; align-items: center; justify-content: space-around; padding: 0 10px; }
        .pagination-dots { display: flex; justify-content: center; gap: 6px; padding-bottom: 8px; }
        .dot { width: 6px; height: 6px; border-radius: 50%; background: #cbd5e1; transition: background 0.3s; }
        .dot.active { background: #06b6d4; width: 8px; height: 8px; }
        .dark .dot { background: #475569; }
        .dark .dot.active { background: #22d3ee; }

        /* Hamburger */
        #floating-hamburger {
            position: fixed; bottom: 100px; right: 16px; 
            width: 50px; height: 50px; border-radius: 16px;
            background: #1f2937; color: white;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 160;
            font-size: 20px; cursor: pointer;
        }
        .dark #floating-hamburger { background: #334155; }

        .btn-xl { height: 56px; width: 56px; border-radius: 16px; display: flex; align-items: center; justify-content: center; background: white; box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: transform 0.1s; font-size: 24px; color: #4b5563; }
        .dark .btn-xl { background-color: #334155; color: #e2e8f0; box-shadow: none; }
        .btn-xl.active { background-color: #e0f2fe; border: 2px solid #06b6d4; color: #06b6d4; }
        .dark .btn-xl.active { background-color: #164e63; border-color: #22d3ee; color: #22d3ee; }

        /* --- MENUS --- */
        #color-menu-popover {
            position: fixed; background: white; z-index: 200; box-shadow: 0 10px 40px rgba(0,0,0,0.25);
            display: none; flex-direction: column; transition: all 0.2s ease-out; overflow: hidden;
        }
        .dark #color-menu-popover { background: #1e293b; border: 1px solid #334155; }
        @media (max-width: 1024px) { #color-menu-popover { bottom: 90px; left: 10px; right: 10px; border-radius: 20px; height: auto; max-height: 80vh; } }
        @media (min-width: 1025px) { #color-menu-popover { top: 80px; left: 340px; width: 340px; border-radius: 20px; } }

        .cm-header { display: flex; align-items: center; padding: 12px 16px; border-bottom: 1px solid #f1f5f9; flex-shrink: 0; }
        .dark .cm-header { border-bottom-color: #334155; }
        .cm-title { font-weight: 800; font-size: 0.9rem; color: #1e293b; flex-grow: 1; text-transform: uppercase; letter-spacing: 0.5px; }
        .dark .cm-title { color: white; }
        .cm-fixed-section { padding: 12px 16px; background: #f8fafc; border-bottom: 1px solid #f1f5f9; flex-shrink: 0; }
        .dark .cm-fixed-section { background: #0f172a; border-bottom-color: #334155; }
        .cm-scroll-content { padding: 16px; overflow-y: auto; flex-grow: 1; }
        .cm-footer { padding: 12px 16px; border-top: 1px solid #f1f5f9; background: #fff; flex-shrink: 0; }
        .dark .cm-footer { background: #1e293b; border-top-color: #334155; }

        #mobile-tools-panel {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: white; border-top-left-radius: 24px; border-top-right-radius: 24px;
            padding: 20px; box-shadow: 0 -10px 40px rgba(0,0,0,0.15);
            transform: translateY(110%); transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 250; max-height: 90vh; overflow-y: auto; padding-bottom: 50px;
        }
        .dark #mobile-tools-panel { background-color: #1e293b; box-shadow: 0 -10px 40px rgba(0,0,0,0.5); }
        #mobile-tools-panel.open { transform: translateY(0); }

        .panel-section { margin-bottom: 14px; background: #f8fafc; padding: 12px 14px; border-radius: 14px; border: 1px solid #f1f5f9; }
        .dark .panel-section { background: #0f172a; border-color: #334155; }
        .panel-title { display: block; font-size: 0.85rem; font-weight: 800; text-transform: uppercase; color: #64748b; margin-bottom: 6px; letter-spacing: 0.5px; }
        .dark .panel-title { color: #94a3b8; }

        .cp-container { position: relative; width: 100%; height: 150px; border-radius: 12px; overflow: hidden; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1); margin-bottom: 12px; touch-action: none; cursor: crosshair; }
        .cp-area { width: 100%; height: 100%; position: relative; }
        .cp-cursor { position: absolute; width: 20px; height: 20px; border: 2px solid white; border-radius: 50%; box-shadow: 0 0 4px rgba(0,0,0,0.5); transform: translate(-50%, -50%); pointer-events: none; }
        .hue-bar-container { width: 100%; height: 24px; border-radius: 12px; position: relative; overflow: hidden; margin-bottom: 12px; cursor: pointer; touch-action: none; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1); }
        .hue-bar-bg { width: 100%; height: 100%; background: linear-gradient(to right, red, yellow, lime, cyan, blue, magenta, red); }
        .hue-bar-cursor { position: absolute; top: 0; width: 10px; height: 100%; background: white; border: 1px solid rgba(0,0,0,0.2); transform: translateX(-50%); pointer-events: none; box-shadow: 0 0 4px rgba(0,0,0,0.3); }
        input[type=range] { flex-grow: 1; accent-color: #06b6d4; height: 4px; background: #e2e8f0; border-radius: 2px; width: 100%; }
        
        #toast-notification { position: fixed; top: 100px; left: 50%; transform: translateX(-50%) translateY(-20px); background-color: rgba(30, 41, 59, 0.95); color: white; padding: 12px 24px; border-radius: 50px; font-weight: bold; font-size: 14px; opacity: 0; pointer-events: none; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 300; box-shadow: 0 4px 15px rgba(0,0,0,0.2); text-align: center; white-space: nowrap; }
        .dark #toast-notification { background-color: rgba(255, 255, 255, 0.9); color: #0f172a; }
        #toast-notification.show { opacity: 1; transform: translateX(-50%) translateY(0); }

        .color-grid-base { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        .color-swatch-lg { aspect-ratio: 1; border-radius: 12px; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border: 1px solid rgba(0,0,0,0.05); }
        .nuance-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; }
        
        .btn-mobile-menu { height: 48px; width: 100%; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: bold; background: white; color: #4b5563; border: 1px solid #e5e7eb; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .dark .btn-mobile-menu { background: #334155; color: #e2e8f0; border-color: #475569; }

        .mobile-flex { display: none !important; } 
        .desktop-only { display: block; }
        
        @media (max-width: 1024px) { 
            .mobile-flex { display: flex !important; } 
            .desktop-only { display: none !important; } 
            #workspace { background-color: #f8fafc; height: 100%; } 
            .dark #workspace { background-color: #020617; } 
        }
        @media (min-width: 1025px) { 
            #workspace { width: calc(100% - 320px); margin-left: 320px; } 
            .floating-actions { display: none; } 
        }
    </style>
</head>
<body class="bg-soft-bg dark:bg-dark-bg text-text-dark dark:text-slate-200 no-context-menu transition-colors duration-300" oncontextmenu="return false;">

    <div id="toast-notification"><i class="fa-solid fa-circle-info mr-2"></i><span id="toast-text">Info</span></div>

    <div class="floating-actions">
        <button id="mobDarkMode" class="float-btn" onclick="toggleDarkMode()"><i class="fa-solid fa-moon"></i></button>
        <div class="w-px h-8 bg-gray-300 dark:bg-slate-600 self-center mx-1"></div>
        <button id="mobUndoFloat" class="float-btn" onclick="undo()"><i class="fa-solid fa-rotate-left"></i></button>
        <button id="mobRedoFloat" class="float-btn" onclick="redo()"><i class="fa-solid fa-rotate-right"></i></button>
    </div>

    <div id="workspace">
        <div id="canvas-wrapper">
            <div id="reference-image"></div>
            <div id="pixel-grid" class="show-grid"></div>
            <div id="selection-overlay"></div>
        </div>

        <div id="lasso-choice-modal" class="lasso-modal">
            <div class="text-center text-sm font-bold text-gray-500 uppercase mb-1 tracking-wider">Sélection</div>
            <button onclick="setSelectionAction('move')" class="w-full py-3 bg-gray-100 dark:bg-slate-700 rounded-xl font-bold text-gray-700 dark:text-slate-200 hover:bg-gray-200 transition flex items-center justify-center gap-2">
                <i class="fa-solid fa-arrows-up-down-left-right"></i> Déplacer
            </button>
            <button onclick="setSelectionAction('copy')" class="w-full py-3 bg-gray-100 dark:bg-slate-700 rounded-xl font-bold text-gray-700 dark:text-slate-200 hover:bg-gray-200 transition flex items-center justify-center gap-2">
                <i class="fa-solid fa-copy"></i> Copier
            </button>
            <button onclick="cancelSelection()" class="w-full py-2 text-red-500 font-bold text-sm hover:bg-red-50 dark:hover:bg-transparent rounded-lg transition">Annuler</button>
        </div>
    </div>

    <div id="lasso-mobile-controls" class="fixed bottom-6 left-1/2 transform -translate-x-1/2 flex gap-4 z-[200] hidden">
        <button onclick="confirmSelectionAction()" class="w-14 h-14 bg-green-500 text-white rounded-full shadow-lg flex items-center justify-center text-xl hover:scale-110 transition border-2 border-white">
            <i class="fa-solid fa-check"></i>
        </button>
        <button onclick="cancelSelection()" class="w-14 h-14 bg-red-500 text-white rounded-full shadow-lg flex items-center justify-center text-xl hover:scale-110 transition border-2 border-white">
            <i class="fa-solid fa-xmark"></i>
        </button>
    </div>

    <div id="swipe-toolbar" class="mobile-flex">
        <div class="toolbar-slides" id="toolbarSlides">
            <div class="toolbar-slide">
                <button id="mobBrush" class="btn-xl active" onclick="setTool('brush')"><i class="fa-solid fa-paintbrush"></i></button>
                <button id="mobFill" class="btn-xl" onclick="setTool('fill')"><i class="fa-solid fa-fill-drip"></i></button>
                <button id="mobEraser" class="btn-xl" onclick="setTool('eraser')"><i class="fa-solid fa-eraser"></i></button>
                <button id="mobHand" class="btn-xl" onclick="setTool('hand')"><i class="fa-solid fa-up-down-left-right"></i></button>
                <button class="btn-xl text-red-500" onclick="createGrid()"><i class="fa-solid fa-trash"></i></button>
                <button id="mobColorBtn" class="btn-xl border-4 border-gray-100 dark:border-slate-600 flex-shrink-0 transition-colors" style="background-color: #06b6d4;" onclick="toggleColorMenu()"></button>
            </div>
            <div class="toolbar-slide">
            
                <button id="mobLine" class="btn-xl" onclick="setTool('line')"><i class="fa-solid fa-slash"></i></button>
                <button id="mobRect" class="btn-xl" onclick="setTool('rect')"><i class="fa-regular fa-square"></i></button>
                <button id="mobCircle" class="btn-xl" onclick="setTool('circle')"><i class="fa-regular fa-circle"></i></button>
                <button id="mobSymBtn" class="btn-xl" onclick="toggleSymmetry()"><i class="fa-solid fa-right-left"></i></button>
				<button id="mobLasso" class="btn-xl" onclick="setTool('lasso')">
    <svg xmlns="http://www.w3.org/2000/svg" width="34" height="34" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
       <path d="M12 20c-4.418 0 -8 -3.582 -8 -8s3.582 -8 8 -8c4.418 0 8 3.582 8 8v1c0 1.657 -1.343 3 -3 3h-3l-5 5"></path>
    </svg>
</button>
                <button id="mobPipette" class="btn-xl" onclick="setTool('pipette')"><i class="fa-solid fa-eye-dropper"></i></button>
            </div>
            <div class="toolbar-slide">
                <button id="mobMagicWand" class="btn-xl" onclick="setTool('magicWand')"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
                <button class="btn-xl" onclick="moveCanvas(0, -1)"><i class="fa-solid fa-arrow-up"></i></button>
                <button class="btn-xl" onclick="moveCanvas(0, 1)"><i class="fa-solid fa-arrow-down"></i></button>
                <button class="btn-xl" onclick="moveCanvas(-1, 0)"><i class="fa-solid fa-arrow-left"></i></button>
                <button class="btn-xl" onclick="moveCanvas(1, 0)"><i class="fa-solid fa-arrow-right"></i></button>
            </div>
        </div>
        <div class="pagination-dots">
            <div class="dot active" id="dot0"></div>
            <div class="dot" id="dot1"></div>
            <div class="dot" id="dot2"></div>
        </div>
    </div>

    <button id="floating-hamburger" class="mobile-flex" onclick="toggleMobileMenu()"><i class="fa-solid fa-bars"></i></button>

    <div id="mobile-tools-panel">
        <button class="absolute top-4 right-4 w-10 h-10 bg-gray-100 dark:bg-slate-700 rounded-full text-gray-600 dark:text-gray-300 flex items-center justify-center hover:bg-gray-200 transition" onclick="closeMobileMenu()">
            <i class="fa-solid fa-xmark text-lg"></i>
        </button>

        <div class="w-12 h-1.5 bg-gray-200 dark:bg-slate-600 rounded-full mx-auto mb-6"></div>
        
        <div class="panel-section">
            <div class="flex justify-between items-center">
                <span class="panel-title mb-0">Afficher la Grille</span>
                <button id="mobGridBtn" class="w-12 h-8 rounded-full bg-primary text-white flex items-center justify-center" onclick="toggleGrid()"><i class="fa-solid fa-check"></i></button>
            </div>
        </div>

        <div class="panel-section">
             <span class="panel-title">Taille Pinceau : <span id="mobBrushVal" class="text-primary">1</span></span>
             <input type="range" id="mobBrushSize" min="1" max="4" value="1" class="w-full h-2 bg-gray-200 dark:bg-slate-600 rounded-lg accent-primary">
        </div>

        <div class="panel-section">
             <span class="panel-title">Taille Grille : <span id="mobGridVal" class="text-primary">16x16</span></span>
             <div class="flex gap-2 items-center">
                <input type="range" id="mobGridSize" min="4" max="128" value="16" class="flex-grow h-2 bg-gray-200 dark:bg-slate-600 rounded-lg accent-primary">
                <button id="mobApplyGrid" class="px-4 py-2 bg-primary text-white rounded-lg font-bold text-base">OK</button>
             </div>
        </div>

        <div class="panel-section">
            <span class="panel-title">Image de fond</span>
            <div class="grid grid-cols-2 gap-3 mb-3">
                <label class="btn-mobile-menu cursor-pointer"><i class="fa-solid fa-upload mr-2"></i> Charger <input type="file" id="mobileImageUpload" accept="image/*" class="hidden"></label>
                <button class="btn-mobile-menu text-blue-600 dark:text-blue-400 border-blue-100 dark:border-blue-900" onclick="pixeliseImage()"><i class="fa-solid fa-wand-sparkles mr-2"></i> Pixeliser</button>
            </div>
            <div id="mobImageControls" class="hidden">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-sm font-bold text-gray-400 uppercase">Transparence</span>
                    <div class="flex gap-2">
                        <button id="mobImgToggle" onclick="toggleImageVisibility()" class="w-10 h-10 bg-white dark:bg-slate-700 rounded shadow flex items-center justify-center text-gray-600 dark:text-slate-300"><i class="fa-solid fa-eye"></i></button>
                        <button onclick="removeImage()" class="w-10 h-10 bg-white dark:bg-slate-700 rounded shadow flex items-center justify-center text-red-500"><i class="fa-solid fa-trash"></i></button>
                    </div>
                </div>
                <input type="range" id="mobOpacitySlider" min="0" max="100" value="0" class="w-full h-2 bg-gray-200 dark:bg-slate-600 rounded-lg accent-primary" oninput="setRefOpacity(this.value)">
            </div>
        </div>

        <div class="panel-section">
             <span class="panel-title">Export & Sauvegarde</span>
             <button class="btn-mobile-menu bg-gray-800 text-white dark:bg-slate-700 font-bold w-full" onclick="exportCanvas()"><i class="fa-solid fa-download mr-2"></i> Télécharger PNG</button>
        </div>
    </div>

    <div id="color-menu-popover">
        <div class="cm-header">
            <div id="cmBackBtn" class="cm-back-btn hidden" onclick="showBaseColors()"><i class="fa-solid fa-chevron-left"></i></div>
            <span id="cmTitle" class="cm-title">Couleurs</span>
            <button onclick="toggleColorMenu()" class="text-gray-400 hover:text-gray-600"><i class="fa-solid fa-xmark"></i></button>
        </div>
        <div class="cm-fixed-section">
            <div class="flex gap-3 items-center">
                <div id="modalColorPreview" class="w-12 h-12 rounded-xl border border-gray-200 dark:border-slate-600 shadow-sm shrink-0" style="background-color: #06B6D4;"></div>
                <div class="flex-grow">
                    <div class="flex items-center bg-white dark:bg-slate-700 rounded-xl px-3 py-2 border border-gray-200 dark:border-slate-600">
                        <span class="text-gray-400 font-bold mr-1">#</span>
                        <input type="text" id="modalHexInput" class="w-full bg-transparent outline-none font-mono font-bold text-gray-700 dark:text-gray-200 uppercase" value="06B6D4" maxlength="6">
                    </div>
                </div>
            </div>
        </div>
        <div id="cmContent" class="cm-scroll-content"></div>
        <div class="cm-footer">
            <h4 class="text-xs font-bold text-gray-400 uppercase mb-2">Récentes</h4>
            <div id="menuRecentColors" class="flex flex-wrap gap-2"></div>
        </div>
    </div>

    <aside class="desktop-only fixed top-0 left-0 bottom-0 w-80 bg-white dark:bg-dark-panel border-r border-gray-200 dark:border-dark-border p-6 overflow-y-auto z-20 custom-scrollbar transition-colors duration-300">
        <div class="flex gap-2 mb-6">
             <button id="undoBtn" onclick="undo()" class="flex-1 py-3 bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 text-gray-600 dark:text-slate-200 rounded-xl font-bold disabled:opacity-50" disabled title="Annuler"><i class="fa-solid fa-rotate-left"></i></button>
             <button id="redoBtn" onclick="redo()" class="flex-1 py-3 bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 text-gray-600 dark:text-slate-200 rounded-xl font-bold disabled:opacity-50" disabled title="Rétablir"><i class="fa-solid fa-rotate-right"></i></button>
             <button id="deskDarkMode" class="w-12 py-3 bg-gray-800 text-yellow-400 hover:bg-black rounded-xl font-bold transition" onclick="toggleDarkMode()" title="Mode Sombre"><i class="fa-solid fa-moon"></i></button>
        </div>

        <div class="bg-white dark:bg-slate-800 p-4 rounded-2xl shadow-sm border border-gray-100 dark:border-slate-700 mb-6">
            <h2 class="text-xs font-bold text-gray-400 dark:text-slate-500 uppercase mb-3">Palette</h2>
            <button id="deskColorBtn" class="w-full h-10 rounded-xl shadow-inner flex items-center justify-center gap-2 text-white font-bold mb-4 transition hover:opacity-90" style="background-color: #06B6D4;" onclick="toggleColorMenu()">
                <i class="fa-solid fa-palette"></i> Changer Couleur
            </button>
            <div id="deskRecentColors" class="flex flex-wrap gap-2"></div>
        </div>

        <div class="grid grid-cols-5 gap-2 mb-4">
            <button id="deskBrush" class="tool-btn active" onclick="setTool('brush')" title="Pinceau"><i class="fa-solid fa-paintbrush"></i></button>
            <button id="deskFill" class="tool-btn" onclick="setTool('fill')" title="Remplir"><i class="fa-solid fa-fill-drip"></i></button>
            <button id="deskEraser" class="tool-btn" onclick="setTool('eraser')" title="Gomme"><i class="fa-solid fa-eraser"></i></button>
            <button id="deskPipette" class="tool-btn" onclick="setTool('pipette')" title="Pipette"><i class="fa-solid fa-eye-dropper"></i></button>
            <button id="deskHand" class="tool-btn" onclick="setTool('hand')" title="Déplacer"><i class="fa-solid fa-up-down-left-right"></i></button>
        </div>
        <h3 class="text-xs font-bold text-gray-400 dark:text-slate-500 uppercase mb-2">Formes & Magie</h3>
        <div class="grid grid-cols-4 gap-2 mb-6">
            <button id="deskLine" class="tool-btn" onclick="setTool('line')" title="Ligne"><i class="fa-solid fa-slash"></i></button>
            <button id="deskRect" class="tool-btn" onclick="setTool('rect')" title="Rectangle"><i class="fa-regular fa-square"></i></button>
            <button id="deskCircle" class="tool-btn" onclick="setTool('circle')" title="Cercle"><i class="fa-regular fa-circle"></i></button>
            <button id="deskMagicWand" class="tool-btn" onclick="setTool('magicWand')" title="Baguette"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
        </div>
        
        <div class="grid grid-cols-3 gap-2 mb-4">
             <button id="deskLasso" class="icon-btn-sm" onclick="setTool('lasso')" title="Sélection Lasso">
    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
       <path d="M12 20c-4.418 0 -8 -3.582 -8 -8s3.582 -8 8 -8c4.418 0 8 3.582 8 8v1c0 1.657 -1.343 3 -3 3h-3l-5 5"></path>
    </svg>
</button>
             <button id="deskSymBtn" class="icon-btn-sm" onclick="toggleSymmetry()" title="Miroir"><i class="fa-solid fa-right-left"></i></button>
             <button id="deskGridBtn" class="icon-btn-sm active bg-primary text-white" onclick="toggleGrid()" title="Grille"><i class="fa-solid fa-border-all"></i></button>
        </div>

        <div class="mb-6 bg-gray-50 dark:bg-slate-800 p-3 rounded-xl border border-gray-100 dark:border-slate-700">
             <div class="flex justify-between text-xs font-bold text-gray-500 dark:text-slate-400 mb-2"><span>Taille Pinceau</span><span id="deskBrushVal" class="text-primary">1</span></div>
             <input type="range" id="deskBrushSize" min="1" max="4" value="1" class="w-full h-2 bg-gray-200 dark:bg-slate-600 rounded-lg accent-primary cursor-pointer">
        </div>

        <div class="bg-gray-50 dark:bg-slate-800 p-3 rounded-xl border border-gray-100 dark:border-slate-700 mb-6">
            <h3 class="text-xs font-bold text-gray-400 dark:text-slate-500 uppercase mb-2 text-center">Déplacer Canevas</h3>
            <div class="flex justify-between gap-2">
                <button onclick="moveCanvas(-1, 0)" class="flex-1 h-10 bg-white dark:bg-slate-700 dark:text-slate-200 rounded shadow-sm hover:bg-gray-100"><i class="fa-solid fa-arrow-left"></i></button>
                <button onclick="moveCanvas(0, -1)" class="flex-1 h-10 bg-white dark:bg-slate-700 dark:text-slate-200 rounded shadow-sm hover:bg-gray-100"><i class="fa-solid fa-arrow-up"></i></button>
                <button onclick="moveCanvas(0, 1)" class="flex-1 h-10 bg-white dark:bg-slate-700 dark:text-slate-200 rounded shadow-sm hover:bg-gray-100"><i class="fa-solid fa-arrow-down"></i></button>
                <button onclick="moveCanvas(1, 0)" class="flex-1 h-10 bg-white dark:bg-slate-700 dark:text-slate-200 rounded shadow-sm hover:bg-gray-100"><i class="fa-solid fa-arrow-right"></i></button>
            </div>
        </div>

        <div class="space-y-3 pt-4 border-t border-gray-100 dark:border-slate-700">
             <div class="bg-blue-50 dark:bg-slate-800 p-3 rounded-xl border border-blue-100 dark:border-slate-700">
                 <div class="flex gap-2 mb-2">
                    <label class="flex-1 py-2 bg-white dark:bg-slate-700 text-blue-600 dark:text-blue-400 rounded-lg text-center cursor-pointer font-bold text-xs border border-blue-200 dark:border-slate-600 hover:bg-blue-50 dark:hover:bg-slate-600 transition">Charger <input type="file" id="imageUpload" accept="image/*" class="hidden"></label>
                    <button id="generatePixelArtBtn" class="flex-1 py-2 bg-blue-600 text-white rounded-lg font-bold text-xs hover:bg-blue-700 transition">Pixeliser</button>
                 </div>
                 <div id="deskImageControls" class="hidden mt-2">
                     <div class="flex justify-between items-center text-xs text-blue-400 mb-1 font-bold"><span>Opacité Image</span><div class="flex items-center gap-2"><span id="opacityVal">0%</span><button id="deskImgToggle" onclick="toggleImageVisibility()" class="bg-white dark:bg-slate-700 p-1 rounded hover:bg-blue-50 text-blue-600"><i class="fa-solid fa-eye"></i></button><button onclick="removeImage()" class="bg-white dark:bg-slate-700 p-1 rounded hover:bg-red-50 text-red-500"><i class="fa-solid fa-trash"></i></button></div></div>
                     <input type="range" id="gridOpacityDesk" min="0" max="100" value="0" class="w-full h-2 bg-blue-200 dark:bg-slate-600 rounded-lg accent-blue-600" oninput="setRefOpacity(this.value)">
                 </div>
             </div>
             <div class="flex items-center gap-2 mt-4">
                <span class="text-xs font-bold text-gray-400 dark:text-slate-500 uppercase whitespace-nowrap w-16">Grille: <br><span id="currentSize" class="text-primary text-sm">16x16</span></span>
                <input type="range" id="deskGridSize" min="4" max="128" value="16" class="flex-grow h-2 bg-gray-200 dark:bg-slate-600 rounded-lg accent-primary">
                <button id="deskApplySize" class="px-2 py-1 bg-gray-200 dark:bg-slate-600 dark:text-white hover:bg-gray-300 rounded text-xs font-bold transition">OK</button>
             </div>
             <div class="flex gap-2 mt-4">
                <button onclick="createGrid()" class="flex-1 py-3 text-red-500 border border-red-200 dark:border-red-900 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-xl font-bold text-sm transition">Vider</button>
                <button onclick="exportCanvas()" class="flex-1 py-3 bg-gray-800 hover:bg-gray-900 text-white rounded-xl font-bold text-sm transition border border-white/20">PNG</button>
             </div>
        </div>
    </aside>

    <script>
        // --- 1. GLOBALS ---
        const pixelGrid = document.getElementById('pixel-grid');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const refImage = document.getElementById('reference-image');
        let gridSize = 16;
        let currentTool = 'brush';
        let currentColor = "#06B6D4";
        let isTransparent = false; 
        let isSymmetry = false;
        let isGridVisible = true;
        let brushSize = 1; 
        let isDarkMode = false; 
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 30;
        let scale = 1;
        let panning = false;
        let startX = 0, startY = 0;
        let translateX = 0, translateY = 0;
        let initialPinchDist = 0;
        let startScale = 1;
        let currentRefImageObj = null;
        let refOpacity = 0.0; 
        let isImageVisible = true;
        let recentColors = ["#06B6D4"];
        let cpHue = 180; let cpSat = 100; let cpVal = 83;
        let colorMenuState = 'base';
        let toastTimeout;
        let isDrawing = false;
        let startPixel = null;
        let cellSizePx = 0;

        // Variables pour le Lasso amélioré
        let lassoStart = null;
        let lassoSelection = []; 
        let isLassoActive = false;
        let lassoAction = null; // 'move' ou 'copy'
        let lassoOffsetX = 0;
        let lassoOffsetY = 0;
        let lassoWidth = 0;
        let lassoHeight = 0;

        const BASE_COLORS = [
            { name: 'Jaune', h: 50, s: 100, v: 100, hex: '#FFD700' },
            { name: 'Orange', h: 30, s: 100, v: 100, hex: '#FFA500' },
            { name: 'Rouge', h: 0, s: 100, v: 100, hex: '#FF0000' },
            { name: 'Rose', h: 300, s: 50, v: 100, hex: '#FF69B4' },
            { name: 'Violet', h: 270, s: 100, v: 100, hex: '#800080' },
            { name: 'Bleu', h: 240, s: 100, v: 100, hex: '#0000FF' },
            { name: 'Vert', h: 120, s: 100, v: 100, hex: '#008000' },
            { name: 'Marron', h: 25, s: 75, v: 50, hex: '#8B4513' },
            { name: 'Gris', h: 0, s: 0, v: 50, hex: '#808080' },
            { name: 'Blanc', h: 0, s: 0, v: 100, hex: '#FFFFFF' },
            { name: 'Noir', h: 0, s: 0, v: 0, hex: '#000000' }
        ];

        // --- 2. UTILS ---
        function showToast(msg) {
            const t = document.getElementById('toast-notification');
            if(!t) return;
            const txt = document.getElementById('toast-text');
            txt.textContent = msg; t.classList.add('show');
            clearTimeout(toastTimeout); toastTimeout = setTimeout(() => t.classList.remove('show'), 2500);
        }
        function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }
        function getPixel(x, y) { if(x < 0 || x >= gridSize || y < 0 || y >= gridSize) return null; return pixelGrid.children[y * gridSize + x]; }
        function getCoords(index) { return { x: index % gridSize, y: Math.floor(index / gridSize) }; }
        
        function hsvToHex(h, s, v) { s /= 100; v /= 100; let c = v * s; let x = c * (1 - Math.abs((h / 60) % 2 - 1)); let m = v - c; let r=0, g=0, b=0; if(0 <= h && h < 60) { r=c; g=x; b=0; } else if(60 <= h && h < 120) { r=x; g=c; b=0; } else if(120 <= h && h < 180) { r=0; g=c; b=x; } else if(180 <= h && h < 240) { r=0; g=x; b=c; } else if(240 <= h && h < 300) { r=x; g=0; b=c; } else if(300 <= h && h < 360) { r=c; g=0; b=x; } const toHex = (n) => { const hex = Math.round((n + m) * 255).toString(16); return hex.length === 1 ? "0" + hex : hex; }; return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase(); }
        function hexToHsv(hex) { let r=0,g=0,b=0; if(hex.length === 4) { r = parseInt("0x"+hex[1]+hex[1]); g = parseInt("0x"+hex[2]+hex[2]); b = parseInt("0x"+hex[3]+hex[3]); } else if (hex.length === 7) { r = parseInt("0x"+hex.substring(1,3)); g = parseInt("0x"+hex.substring(3,5)); b = parseInt("0x"+hex.substring(5,7)); } r /= 255; g /= 255; b /= 255; let cmin = Math.min(r,g,b), cmax = Math.max(r,g,b), delta = cmax - cmin; let h=0, s=0, v=0; if (delta === 0) h = 0; else if (cmax === r) h = ((g - b) / delta) % 6; else if (cmax === g) h = (b - r) / delta + 2; else h = (r - g) / delta + 4; h = Math.round(h * 60); if (h < 0) h += 360; v = Math.round(cmax * 100); s = cmax === 0 ? 0 : Math.round((delta / cmax) * 100); return {h, s, v}; }

        // --- 3. CORE FUNCTIONS ---
        function createGrid() {
            pixelGrid.innerHTML = ''; 
            const maxScreenW = Math.min(window.innerWidth * 0.95, 500);
            let rawCellSize = Math.floor(maxScreenW / gridSize);
            if (rawCellSize < 1) rawCellSize = 1;
            const exactWidth = rawCellSize * gridSize;
            cellSizePx = rawCellSize;
            canvasWrapper.style.width = `${exactWidth}px`;
            canvasWrapper.style.height = `${exactWidth}px`;
            pixelGrid.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            pixelGrid.style.setProperty('--grid-cell-px', `${cellSizePx}px`);
            const fragment = document.createDocumentFragment();
            const totalPixels = gridSize * gridSize;
            for (let i = 0; i < totalPixels; i++) {
                const div = document.createElement('div');
                div.className = 'pixel';
                div.style.backgroundColor = 'transparent';
                fragment.appendChild(div);
            }
            pixelGrid.appendChild(fragment);
            history = []; historyIndex = -1;
            saveState();
            cancelSelection(); 
        }

        function saveState() {
            const state = Array.from(pixelGrid.children).map(p => p.style.backgroundColor);
            if (historyIndex < history.length - 1) history.splice(historyIndex + 1);
            history.push(state);
            if (history.length > MAX_HISTORY) history.shift(); else historyIndex++;
            updateUndoRedoUI();
        }

        function undo() {
            if (historyIndex > 0) { historyIndex--; restoreState(history[historyIndex]); updateUndoRedoUI(); }
        }
        function redo() {
            if (historyIndex < history.length - 1) { historyIndex++; restoreState(history[historyIndex]); updateUndoRedoUI(); }
        }
        function restoreState(state) {
            const pixels = pixelGrid.children; for(let i=0; i<pixels.length; i++) pixels[i].style.backgroundColor = state[i];
        }
        function updateUndoRedoUI() {
            const canUndo = historyIndex > 0; const canRedo = historyIndex < history.length - 1;
            document.getElementById('undoBtn').disabled = !canUndo; document.getElementById('redoBtn').disabled = !canRedo;
            document.getElementById('mobUndoFloat').disabled = !canUndo; document.getElementById('mobRedoFloat').disabled = !canRedo;
        }

        function setTool(t) {
            currentTool = t; isTransparent = (t === 'eraser');
            document.body.classList.remove('cursor-move-mode', 'pipette-mode', 'lasso-mode', 'lasso-moving');
            
            if(currentTool === 'hand') document.body.classList.add('cursor-move-mode'); 
            else if(currentTool === 'pipette') { document.body.classList.add('pipette-mode'); showToast("Pipette : Touchez une couleur"); }
            else if(currentTool === 'lasso') { document.body.classList.add('lasso-mode'); showToast("Lasso : Encadrez la zone"); }
            
            updateToolUI();
            if (t !== 'lasso' && isLassoActive) cancelSelection();
        }

        function updateToolUI() {
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('tool-active'));
            document.querySelectorAll('.icon-btn-sm').forEach(b => {
                if(b.id !== 'deskGridBtn' && b.id !== 'deskSymBtn') b.classList.remove('active'); 
            });

            const deskBtn = document.getElementById(`desk${capitalize(currentTool)}`); 
            if(deskBtn) {
                if (deskBtn.classList.contains('icon-btn-sm')) deskBtn.classList.add('active');
                else deskBtn.classList.add('tool-active');
            }

            const mobToolIds = ['mobBrush', 'mobFill', 'mobEraser', 'mobHand', 'mobPipette', 'mobMagicWand', 'mobLine', 'mobRect', 'mobCircle', 'mobLasso'];
            mobToolIds.forEach(id => { 
                const el = document.getElementById(id); 
                if(el) el.classList.remove('active'); 
            });
            
            const mobBtn = document.getElementById(`mob${capitalize(currentTool)}`);
            if(mobBtn) mobBtn.classList.add('active');

            const symState = isSymmetry;
            const mobSym = document.getElementById('mobSymBtn');
            if(mobSym) { if(symState) mobSym.classList.add('active'); else mobSym.classList.remove('active'); }
            const deskSym = document.getElementById('deskSymBtn');
            if(deskSym) { if(symState) deskSym.classList.add('active'); else deskSym.classList.remove('active'); }

            const gridState = isGridVisible;
            const mobGrid = document.getElementById('mobGridBtn');
            if(mobGrid) { if(gridState) { mobGrid.classList.add('bg-primary', 'text-white'); mobGrid.classList.remove('bg-gray-200'); } else { mobGrid.classList.remove('bg-primary', 'text-white'); mobGrid.classList.add('bg-gray-200'); } }
            const deskGrid = document.getElementById('deskGridBtn');
            if(deskGrid) { if(gridState) { deskGrid.classList.add('active'); } else { deskGrid.classList.remove('active'); } }

            if(pixelGrid) {
                if(isGridVisible) pixelGrid.classList.add('show-grid');
                else pixelGrid.classList.remove('show-grid');
            }
        }

        function toggleGrid() { isGridVisible = !isGridVisible; updateToolUI(); }
        function toggleSymmetry() { isSymmetry = !isSymmetry; updateToolUI(); }
        
        function toggleDarkMode(forceState) {
            const html = document.documentElement;
            if (forceState !== undefined) { isDarkMode = forceState; } else { isDarkMode = !isDarkMode; }
            if (isDarkMode) { html.classList.add('dark'); document.getElementById('deskDarkMode').innerHTML = '<i class="fa-solid fa-sun"></i>'; document.getElementById('deskDarkMode').classList.remove('text-yellow-400', 'bg-gray-800'); document.getElementById('deskDarkMode').classList.add('text-gray-800', 'bg-yellow-400'); document.getElementById('mobDarkMode').innerHTML = '<i class="fa-solid fa-sun"></i>'; } 
            else { html.classList.remove('dark'); document.getElementById('deskDarkMode').innerHTML = '<i class="fa-solid fa-moon"></i>'; document.getElementById('deskDarkMode').classList.remove('text-gray-800', 'bg-yellow-400'); document.getElementById('deskDarkMode').classList.add('text-yellow-400', 'bg-gray-800'); document.getElementById('mobDarkMode').innerHTML = '<i class="fa-solid fa-moon"></i>'; }
            localStorage.setItem('pixelArtDarkMode', isDarkMode); updateToolUI();
        }

        function getPointerTarget(e) {
             const rect = pixelGrid.getBoundingClientRect();
             const clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
             const clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
             if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) return null;
             const x = Math.floor((clientX - rect.left) / (rect.width / gridSize));
             const y = Math.floor((clientY - rect.top) / (rect.height / gridSize));
             return { x, y };
        }

        // --- LOGIQUE LASSO & SELECTION AMÉLIORÉE ---
        function updateSelectionOverlay(start, end) {
            const overlay = document.getElementById('selection-overlay');
            const x1 = Math.min(start.x, end.x);
            const y1 = Math.min(start.y, end.y);
            const x2 = Math.max(start.x, end.x);
            const y2 = Math.max(start.y, end.y);
            
            const left = x1 * cellSizePx;
            const top = y1 * cellSizePx;
            const width = (x2 - x1 + 1) * cellSizePx;
            const height = (y2 - y1 + 1) * cellSizePx;

            overlay.style.left = `${left}px`;
            overlay.style.top = `${top}px`;
            overlay.style.width = `${width}px`;
            overlay.style.height = `${height}px`;
            overlay.style.display = 'block';
        }

        function finishLassoSelection(endPixel) {
            if (!lassoStart) return;
            
            let x1 = Math.min(lassoStart.x, endPixel.x);
            let y1 = Math.min(lassoStart.y, endPixel.y);
            let x2 = Math.max(lassoStart.x, endPixel.x);
            let y2 = Math.max(lassoStart.y, endPixel.y);

            // 1. Analyse du contenu brut et détection du fond
            let rawPixels = [];
            let borderColors = {};
            let perimeterSize = 0;

            for(let y=y1; y<=y2; y++) {
                for(let x=x1; x<=x2; x++) {
                    const p = getPixel(x, y);
                    const col = p.style.backgroundColor;
                    const isBorder = (x === x1 || x === x2 || y === y1 || y === y2);
                    
                    if (isBorder) {
                        perimeterSize++;
                        if (col && col !== 'transparent' && col !== 'rgba(0, 0, 0, 0)') {
                            borderColors[col] = (borderColors[col] || 0) + 1;
                        }
                    }
                    
                    if (col && col !== 'transparent' && col !== 'rgba(0, 0, 0, 0)') {
                        rawPixels.push({x, y, color: col});
                    }
                }
            }

            if (rawPixels.length === 0) {
                showToast("Zone vide !");
                cancelSelection();
                return;
            }

            // 2. Détection "Smart Background"
            // Si une couleur compose plus de 75% du bord, on la considère comme fond
            let ignoredColor = null;
            for (let c in borderColors) {
                if (borderColors[c] > perimeterSize * 0.75) {
                    ignoredColor = c;
                    break;
                }
            }

            // 3. Filtrage et calcul de la Bounding Box réelle (Crop)
            lassoSelection = [];
            let minX = gridSize, minY = gridSize, maxX = -1, maxY = -1;

            rawPixels.forEach(p => {
                // On ignore si c'est la couleur de fond détectée
                if (p.color === ignoredColor) return;

                // Update bounds
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;

                lassoSelection.push({
                    absX: p.x,
                    absY: p.y,
                    color: p.color
                });
            });

            if (lassoSelection.length === 0) {
                showToast("Seul le fond a été sélectionné.");
                cancelSelection();
                return;
            }

            // 4. Normalisation par rapport à la nouvelle Bounding Box
            lassoWidth = maxX - minX + 1;
            lassoHeight = maxY - minY + 1;
            lassoOffsetX = Math.floor(lassoWidth / 2);
            lassoOffsetY = Math.floor(lassoHeight / 2);

            // On réécrit les coordonnées en relatif par rapport au coin haut-gauche de la bbox
            lassoSelection = lassoSelection.map(p => ({
                relX: p.absX - minX,
                relY: p.absY - minY,
                color: p.color,
                origX: p.absX, // Important pour le mode 'move' (effacement)
                origY: p.absY
            }));

            // Afficher menu choix
            const modal = document.getElementById('lasso-choice-modal');
            modal.style.display = 'flex';
            isLassoActive = true;
        }

        function setSelectionAction(action) {
            lassoAction = action; 
            document.getElementById('lasso-choice-modal').style.display = 'none';
            document.body.classList.add('lasso-moving');

            // Afficher contrôles mobile
            if(window.innerWidth <= 1024) {
                 document.getElementById('lasso-mobile-controls').classList.remove('hidden');
                 document.getElementById('swipe-toolbar').classList.add('hidden');
                 document.getElementById('floating-hamburger').classList.add('hidden');
            }

            if (action === 'move') {
                // Effacer les originaux immédiatement
                lassoSelection.forEach(p => {
                    const pixel = getPixel(p.origX, p.origY);
                    if(pixel) pixel.style.backgroundColor = 'transparent';
                });
                showToast("Déplacez. Cliquez/Tap pour poser.");
            } else {
                showToast("Copiez. Cliquez/Tap pour tamponner.");
            }
        }

        function previewLassoAction(targetPixel) {
            if (!isLassoActive || !lassoAction) return;

            // Nettoyage propre des previews
            document.querySelectorAll('.pixel.preview-pixel').forEach(p => {
                p.style.backgroundColor = p.dataset.origColor || 'transparent';
                p.classList.remove('preview-pixel');
                delete p.dataset.origColor;
            });

            // Dessin du fantôme
            lassoSelection.forEach(item => {
                // Calcul position centrée sur le curseur
                const targetX = targetPixel.x + item.relX - lassoOffsetX;
                const targetY = targetPixel.y + item.relY - lassoOffsetY;
                
                if (targetX >= 0 && targetX < gridSize && targetY >= 0 && targetY < gridSize) {
                    const p = getPixel(targetX, targetY);
                    if (!p.dataset.origColor) {
                        p.dataset.origColor = p.style.backgroundColor;
                        p.classList.add('preview-pixel');
                    }
                    p.style.backgroundColor = item.color;
                }
            });
        }

        function stampSelection(targetPixel) {
            if (!isLassoActive || !lassoAction) return;

            // Applique réellement les pixels (Tampon)
            let modified = false;
            lassoSelection.forEach(item => {
                const targetX = targetPixel.x + item.relX - lassoOffsetX;
                const targetY = targetPixel.y + item.relY - lassoOffsetY;
                if (targetX >= 0 && targetX < gridSize && targetY >= 0 && targetY < gridSize) {
                    const p = getPixel(targetX, targetY);
                    // Supprimer flags preview s'ils sont là
                    if(p.classList.contains('preview-pixel')) {
                        p.classList.remove('preview-pixel');
                        delete p.dataset.origColor; 
                    }
                    p.style.backgroundColor = item.color;
                    modified = true;
                }
            });

            if (modified) {
                saveState(); // Sauvegarde chaque tampon comme une étape
                // Réapplique le preview par dessus pour ne pas perdre le visuel du curseur
                previewLassoAction(targetPixel);
            }
        }

        function confirmSelectionAction() {
            // Nettoyage final
            document.querySelectorAll('.pixel.preview-pixel').forEach(p => {
                p.classList.remove('preview-pixel');
                delete p.dataset.origColor;
            });
            
            // Reset complet
            lassoStart = null;
            lassoSelection = [];
            isLassoActive = false;
            lassoAction = null;
            document.getElementById('selection-overlay').style.display = 'none';
            document.body.classList.remove('lasso-moving');
            
            // UI Reset
            document.getElementById('lasso-mobile-controls').classList.add('hidden');
            if(window.innerWidth <= 1024) {
                document.getElementById('swipe-toolbar').classList.remove('hidden');
                document.getElementById('floating-hamburger').classList.remove('hidden');
            }
            
            showToast("Terminé !");
        }

        function cancelSelection() {
            if (lassoAction === 'move' && isLassoActive) {
                 // Si on était en move, les originaux ont été effacés, il faut restaurer
                 restoreState(history[historyIndex]); 
            }
            
            lassoStart = null;
            lassoSelection = [];
            isLassoActive = false;
            lassoAction = null;
            document.getElementById('selection-overlay').style.display = 'none';
            document.getElementById('lasso-choice-modal').style.display = 'none';
            document.body.classList.remove('lasso-moving');
            
            document.querySelectorAll('.pixel.preview-pixel').forEach(p => {
                p.style.backgroundColor = p.dataset.origColor || 'transparent';
                p.classList.remove('preview-pixel');
                delete p.dataset.origColor;
            });

            // UI Reset
            document.getElementById('lasso-mobile-controls').classList.add('hidden');
            if(window.innerWidth <= 1024) {
                document.getElementById('swipe-toolbar').classList.remove('hidden');
                document.getElementById('floating-hamburger').classList.remove('hidden');
            }
        }

        function handleStart(e) {
            if(e.target.closest('.zoom-controls') || e.target.closest('.floating-actions') || e.target.closest('.lasso-modal') || e.target.closest('#lasso-mobile-controls')) return;

            // --- CLIC DROIT pour VALIDER ---
            if (e.button === 2) {
                if (isLassoActive && lassoAction) {
                    confirmSelectionAction();
                    return;
                }
            }

            // GESTION LASSO
            if (currentTool === 'lasso') {
                const pt = getPointerTarget(e);
                
                // Mode Action (Move/Copy)
                if (isLassoActive && lassoAction) {
                    if (pt) {
                        // Clic Gauche ou Tap = TAMPONNER
                        stampSelection(pt);
                    }
                    return; 
                }

                // Nouvelle sélection
                if (!isLassoActive && pt) {
                    lassoStart = pt;
                    isDrawing = true;
                    document.getElementById('selection-overlay').style.display = 'none';
                    return;
                }
                return;
            }

            // GESTION AUTRES OUTILS (Pipette, etc)
            if (currentTool === 'pipette') {
                e.preventDefault(); 
                let foundColor = null;
                const pt = getPointerTarget(e);
                if(pt) {
                    const p = getPixel(pt.x, pt.y);
                    if(p && p.style.backgroundColor && p.style.backgroundColor !== 'transparent' && p.style.backgroundColor !== 'rgba(0, 0, 0, 0)') { 
                        foundColor = p.style.backgroundColor; 
                    }
                }
                if (!foundColor) {
                    const clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
                    const clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
                    try { const imgColor = getColorFromImage(clientX, clientY); if (imgColor) foundColor = imgColor; } catch(err) { console.log(err); }
                }
                if (foundColor) { setAppColor(foundColor); showToast("Couleur copiée !"); } else { showToast("Pinceau activé"); }
                setTool('brush'); 
                return; 
            }

            if(currentTool === 'hand') return;
            const pt = getPointerTarget(e);
            if(!pt) return;

            e.preventDefault(); 
            isDrawing = true; 
            startPixel = pt;

            // Gomme sur clic droit
            if(e.button === 2 || (e.buttons === 2)) { drawAction(pt, true); return; }

            if (currentTool === 'fill') { fillTool(startPixel.x, startPixel.y, isTransparent ? 'transparent' : currentColor); saveState(); isDrawing = false; } 
            else if (currentTool === 'magicWand') { magicWandAction(startPixel.x, startPixel.y); saveState(); isDrawing = false; } 
            else if (['brush', 'eraser'].includes(currentTool)) { drawAction(pt); }
        }

        function handleMove(e) {
            const pt = getPointerTarget(e);
            
            // LASSO LOGIC
            if (currentTool === 'lasso') {
                if (!pt) return;

                if (isDrawing && lassoStart) {
                    updateSelectionOverlay(lassoStart, pt);
                    return;
                }

                if (isLassoActive && lassoAction) {
                    // Le fantôme suit la souris/doigt
                    previewLassoAction(pt);
                    return;
                }
            }

            if(!isDrawing) return;
            if(!pt) return;
            if(e.buttons === 2) { drawAction(pt, true); return; }
            if(['brush', 'eraser'].includes(currentTool)) { drawAction(pt); } 
            else if (['line', 'rect', 'circle'].includes(currentTool)) { restoreState(history[historyIndex]); drawShape(startPixel, pt, currentTool); }
        }

        function handleEnd(e) { 
            if (currentTool === 'lasso' && isDrawing) {
                isDrawing = false;
                const pt = getPointerTarget(e);
                if (pt && lassoStart) {
                    finishLassoSelection(pt);
                }
                lassoStart = null; 
            }
            
            if(isDrawing) { saveState(); isDrawing = false; startPixel = null; } 
        }

        function getColorFromImage(clientX, clientY) {
            if (!currentRefImageObj) return null;
            const wrapper = document.getElementById('canvas-wrapper');
            const rect = wrapper.getBoundingClientRect();
            const x = clientX - rect.left; const y = clientY - rect.top;
            const imgW = currentRefImageObj.width; const imgH = currentRefImageObj.height;
            const wrapW = wrapper.clientWidth; const wrapH = wrapper.clientHeight;
            const imgRatio = imgW / imgH; const wrapRatio = wrapW / wrapH;
            let renderW, renderH, offsetX, offsetY;
            if (imgRatio > wrapRatio) { renderW = wrapW; renderH = wrapW / imgRatio; offsetX = 0; offsetY = (wrapH - renderH) / 2; } else { renderH = wrapH; renderW = wrapH * imgRatio; offsetX = (wrapW - renderW) / 2; offsetY = 0; }
            if (x < offsetX || x > offsetX + renderW || y < offsetY || y > offsetY + renderH) return null;
            const sourceX = Math.floor((x - offsetX) * (imgW / renderW));
            const sourceY = Math.floor((y - offsetY) * (imgH / renderH));
            const canvas = document.createElement('canvas'); canvas.width = 1; canvas.height = 1;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(currentRefImageObj, sourceX, sourceY, 1, 1, 0, 0, 1, 1);
            const p = ctx.getImageData(0, 0, 1, 1).data;
            if (p[3] === 0) return null;
            return "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1).toUpperCase();
        }

        function paintPixel(x, y, color) {
            let size = brushSize; let offset = Math.floor((size - 1) / 2);
            for (let dx = -offset; dx < size - offset; dx++) {
                for (let dy = -offset; dy < size - offset; dy++) {
                    let px = x + dx, py = y + dy; const pixel = getPixel(px, py);
                    if(pixel) { pixel.style.backgroundColor = color; if(isSymmetry) { const symPixel = getPixel(gridSize - 1 - px, py); if(symPixel) symPixel.style.backgroundColor = color; } }
                }
            }
        }

        function drawAction(coords, forceEraser = false) {
            const color = (currentTool === 'eraser' || isTransparent || forceEraser) ? 'transparent' : currentColor;
            paintPixel(coords.x, coords.y, color);
        }

        function drawShape(start, end, type) {
            const color = isTransparent ? 'transparent' : currentColor;
            if(type === 'line') { let x0 = start.x, y0 = start.y, x1 = end.x, y1 = end.y; let dx = Math.abs(x1-x0), sx = x0<x1 ? 1 : -1; let dy = -Math.abs(y1-y0), sy = y0<y1 ? 1 : -1; let err = dx+dy; while(true){ paintPixel(x0, y0, color); if (x0===x1 && y0===y1) break; let e2 = 2*err; if (e2 >= dy) { err += dy; x0 += sx; } if (e2 <= dx) { err += dx; y0 += sy; } } } 
            else if (type === 'rect') { let x1 = Math.min(start.x, end.x), x2 = Math.max(start.x, end.x); let y1 = Math.min(start.y, end.y), y2 = Math.max(start.y, end.y); for(let x=x1; x<=x2; x++) { paintPixel(x, y1, color); paintPixel(x, y2, color); } for(let y=y1; y<=y2; y++) { paintPixel(x1, y, color); paintPixel(x2, y, color); } } 
            else if (type === 'circle') { let r = Math.round(Math.sqrt(Math.pow(end.x-start.x, 2) + Math.pow(end.y-start.y, 2))); let xc = start.x, yc = start.y, x = 0, y = r, d = 3 - 2 * r; const drawC = (x,y) => { paintPixel(xc+x, yc+y, color); paintPixel(xc-x, yc+y, color); paintPixel(xc+x, yc-y, color); paintPixel(xc-x, yc-y, color); paintPixel(xc+y, yc+x, color); paintPixel(xc-y, yc+x, color); paintPixel(xc+y, yc-x, color); paintPixel(xc-y, yc-x, color); }; while(y >= x) { drawC(x, y); x++; if(d > 0) { y--; d = d + 4 * (x - y) + 10; } else { d = d + 4 * x + 6; } } }
        }

        function fillTool(x, y, color) {
            const targetPixel = getPixel(x, y); if (!targetPixel) return;
            const targetColor = targetPixel.style.backgroundColor; if (targetColor === color) return;
            const stack = [[x, y]]; const processed = new Set();
            while(stack.length) {
                const [cx, cy] = stack.pop(); const key = `${cx},${cy}`; if (processed.has(key)) continue;
                const p = getPixel(cx, cy);
                if(p && p.style.backgroundColor === targetColor) { p.style.backgroundColor = color; processed.add(key); stack.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]); }
            }
        }

        function magicWandAction(x, y) {
            const targetPixel = getPixel(x, y); const targetColor = targetPixel.style.backgroundColor;
            if(targetColor === 'transparent' || targetColor === 'rgba(0, 0, 0, 0)' || targetColor === '') return;
            fillTool(x, y, 'transparent');
        }

        function moveCanvas(dx, dy) {
            const current = history[historyIndex] || Array.from(pixelGrid.children).map(p=>p.style.backgroundColor);
            const next = new Array(gridSize*gridSize).fill('transparent');
            for(let y=0; y<gridSize; y++) { for(let x=0; x<gridSize; x++) { let nx = x + dx, ny = y + dy; if(nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) { next[ny*gridSize + nx] = current[y*gridSize + x]; } } }
            restoreState(next); saveState();
        }

        // --- IMAGE, COLOR & UI EXTRAS ---
        function setRefOpacity(val) {
            refOpacity = val / 100;
            if(isImageVisible) { refImage.style.opacity = refOpacity; }
            pixelGrid.style.opacity = 1 - refOpacity;
            const disp = document.getElementById('opacityVal');
            if(disp) disp.textContent = val + '%';
            const deskSlider = document.getElementById('gridOpacityDesk');
            if(deskSlider) deskSlider.value = val;
            const mobSlider = document.getElementById('mobOpacitySlider');
            if(mobSlider) mobSlider.value = val;
        }
        function toggleImageVisibility() { if(!currentRefImageObj) return; isImageVisible = !isImageVisible; refImage.style.opacity = isImageVisible ? refOpacity : 0; const icon = isImageVisible ? '<i class="fa-solid fa-eye"></i>' : '<i class="fa-solid fa-eye-slash"></i>'; document.getElementById('deskImgToggle').innerHTML = icon; document.getElementById('mobImgToggle').innerHTML = icon; setRefOpacity(refOpacity * 100); }
        function removeImage() { currentRefImageObj = null; refImage.style.backgroundImage = 'none'; document.getElementById('deskImageControls').classList.add('hidden'); document.getElementById('mobImageControls').classList.add('hidden'); document.getElementById('imageUpload').value = ''; document.getElementById('mobileImageUpload').value = ''; pixelGrid.style.opacity = 1; }
        function handleImageUpload(e) { const f = e.target.files[0]; if(!f) return; const r = new FileReader(); r.onload = () => { const img = new Image(); img.onload = () => { currentRefImageObj = img; refImage.style.backgroundImage = `url('${r.result}')`; document.getElementById('deskImageControls').classList.remove('hidden'); document.getElementById('mobImageControls').classList.remove('hidden'); setRefOpacity(50); pixelGrid.style.opacity = 1; }; img.src = r.result; }; r.readAsDataURL(f); closeMobileMenu(); }
        function pixeliseImage() { if(!currentRefImageObj) { alert("Chargez une image d'abord !"); return; } const c = document.createElement('canvas'); c.width = gridSize; c.height = gridSize; const ctx = c.getContext('2d'); ctx.drawImage(currentRefImageObj, 0, 0, gridSize, gridSize); const data = ctx.getImageData(0,0,gridSize,gridSize).data; const newState = []; for(let i=0; i<data.length; i+=4) { if(data[i+3] < 100) newState.push('transparent'); else newState.push("#" + ((1<<24)+(data[i]<<16)+(data[i+1]<<8)+data[i+2]).toString(16).slice(1)); } restoreState(newState); saveState(); pixelGrid.style.opacity = 1; closeMobileMenu(); }
        function exportCanvas() { const c = document.createElement('canvas'); c.width=gridSize*20; c.height=gridSize*20; const ctx = c.getContext('2d'); Array.from(pixelGrid.children).forEach((p,i) => { const col = p.style.backgroundColor; if(col && col !== 'transparent' && col !== 'rgba(0, 0, 0, 0)' && col !== 'white') { ctx.fillStyle = col; ctx.fillRect((i%gridSize)*20, Math.floor(i/gridSize)*20, 20, 20); } }); const a = document.createElement('a'); a.download = 'pixelart.png'; a.href = c.toDataURL(); a.click(); closeMobileMenu(); }
        function updateGridText(val, id) { const el = document.getElementById(id); if(el) el.textContent = `${val}x${val}`; }

        function toggleColorMenu() { const menu = document.getElementById('color-menu-popover'); if (menu.style.display === 'flex') { menu.style.display = 'none'; } else { menu.style.display = 'flex'; showBaseColors(); updateModalPreview(currentColor); } }
        function showBaseColors() { colorMenuState = 'base'; document.getElementById('cmTitle').textContent = 'Couleurs'; document.getElementById('cmBackBtn').classList.add('hidden'); let html = `<div class="mb-4"><h4 class="text-xs font-bold text-gray-400 uppercase mb-2">Bases</h4><div class="color-grid-base">`; BASE_COLORS.forEach((c, idx) => { html += `<div class="color-swatch-lg" style="background-color:${c.hex}" onclick="selectBaseColor(${idx})"></div>`; }); html += `</div></div>`; html += `<button onclick="showManualPicker()" class="w-full py-3 mt-2 bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-slate-200 rounded-xl font-bold text-sm flex items-center justify-center"><i class="fa-solid fa-sliders mr-2"></i> Personnalisé</button>`; document.getElementById('cmContent').innerHTML = html; }
        function selectBaseColor(idx) { const base = BASE_COLORS[idx]; colorMenuState = 'shades'; document.getElementById('cmTitle').textContent = 'Nuances ' + base.name; document.getElementById('cmBackBtn').classList.remove('hidden'); document.getElementById('cmBackBtn').onclick = showBaseColors; let html = `<div class="nuance-grid">`; if (base.s === 0) { for(let i=0; i<20; i++) { let v = 100 - (i * (100/19)); let hex = hsvToHex(0, 0, v); html += `<div class="h-10 rounded-md cursor-pointer shadow-sm" style="background-color:${hex}" onclick="pickColor('${hex}')"></div>`; } } else { for(let i=0; i<20; i++) { let s = 100 - (Math.floor(i/5) * 20); let v = 100 - ((i%5) * 15); let hex = hsvToHex(base.h, s, v); html += `<div class="h-10 rounded-md cursor-pointer shadow-sm" style="background-color:${hex}" onclick="pickColor('${hex}')"></div>`; } } html += `</div>`; document.getElementById('cmContent').innerHTML = html; }
        function showManualPicker() { colorMenuState = 'manual'; document.getElementById('cmTitle').textContent = 'Personnalisé'; document.getElementById('cmBackBtn').classList.remove('hidden'); document.getElementById('cmBackBtn').onclick = showBaseColors; let html = `<div class="cp-container"><div class="cp-area" id="cpSatArea"><div class="cp-cursor" id="cpCursor"></div></div></div><div class="hue-bar-container" id="cpHueSlider"><div class="hue-bar-bg"></div><div class="hue-bar-cursor" id="cpHueCursor"></div></div><div class="manual-sliders"><div class="range-wrapper"><span class="range-label">S</span><input type="range" min="0" max="100" value="${cpSat}" oninput="updateSatSlider(this.value)"></div><div class="range-wrapper"><span class="range-label">V</span><input type="range" min="0" max="100" value="${cpVal}" oninput="updateValSlider(this.value)"></div></div><button onclick="pickColor(hsvToHex(cpHue, cpSat, cpVal))" class="w-full py-3 mt-4 bg-primary text-white font-bold rounded-xl shadow-md">Valider</button>`; document.getElementById('cmContent').innerHTML = html; setTimeout(initCustomColorPicker, 50); }
        function pickColor(hex) { setAppColor(hex); setTool('brush'); toggleColorMenu(); }
        function updateSatSlider(val) { cpSat = parseInt(val); updateCursors(); updateColorFromPicker(); }
        function updateValSlider(val) { cpVal = parseInt(val); updateCursors(); updateColorFromPicker(); }
        
        function updateRecentColorsUI() { 
            const deskCont = document.getElementById('deskRecentColors');
            const menuCont = document.getElementById('menuRecentColors');
            if(deskCont) deskCont.innerHTML = '';
            if(menuCont) menuCont.innerHTML = '';
            recentColors.forEach(c => {
                if(deskCont) {
                    const d = document.createElement('div');
                    d.className = `w-6 h-6 rounded-full cursor-pointer border border-gray-200 dark:border-gray-600`;
                    d.style.backgroundColor = c;
                    d.onclick = () => { setAppColor(c); setTool('brush'); };
                    deskCont.appendChild(d);
                }
                if(menuCont) {
                    const m = document.createElement('div');
                    m.className = `w-6 h-6 rounded-full cursor-pointer border border-gray-200 dark:border-gray-600`;
                    m.style.backgroundColor = c;
                    m.onclick = () => { setAppColor(c); setTool('brush'); toggleColorMenu(); };
                    menuCont.appendChild(m);
                }
            });
        }

        function updateModalPreview(hex) { if(!/^#[0-9A-F]{6}$/i.test(hex) && !hex.startsWith('#')) return; document.getElementById('modalColorPreview').style.backgroundColor = hex; if(hex.startsWith('#')) document.getElementById('modalHexInput').value = hex.substring(1); }
        function openColorModal() { toggleColorMenu(); }
        function initCustomColorPicker() { const satArea = document.getElementById('cpSatArea'); if(!satArea) return; const hueSlider = document.getElementById('cpHueSlider'); updateSatArea(cpHue); updateCursors(); const handleHue = (e) => { e.preventDefault(); const rect = hueSlider.getBoundingClientRect(); let x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left; x = Math.max(0, Math.min(x, rect.width)); cpHue = Math.round((x / rect.width) * 360); updateSatArea(cpHue); updateColorFromPicker(); updateCursors(); }; hueSlider.onpointerdown = (e) => { hueSlider.setPointerCapture(e.pointerId); hueSlider.onpointermove = handleHue; handleHue(e); }; hueSlider.onpointerup = (e) => { hueSlider.onpointermove = null; hueSlider.releasePointerCapture(e.pointerId); }; const handleSat = (e) => { e.preventDefault(); const rect = satArea.getBoundingClientRect(); let x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left; let y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top; x = Math.max(0, Math.min(x, rect.width)); y = Math.max(0, Math.min(y, rect.height)); cpSat = Math.round((x / rect.width) * 100); cpVal = Math.round(100 - (y / rect.height) * 100); updateColorFromPicker(); updateCursors(); }; satArea.onpointerdown = (e) => { satArea.setPointerCapture(e.pointerId); satArea.onpointermove = handleSat; handleSat(e); }; satArea.onpointerup = (e) => { satArea.onpointermove = null; satArea.releasePointerCapture(e.pointerId); }; }
        function updateSatArea(hue) { const el = document.getElementById('cpSatArea'); if(el) { el.style.backgroundColor = `hsl(${hue}, 100%, 50%)`; el.style.backgroundImage = 'linear-gradient(to right, white, transparent), linear-gradient(to bottom, transparent, black)'; } }
        function updateCursors() { const hC = document.getElementById('cpHueCursor'); if(hC) hC.style.left = `${(cpHue / 360) * 100}%`; const sC = document.getElementById('cpCursor'); if(sC) { sC.style.left = `${cpSat}%`; sC.style.top = `${100 - cpVal}%`; sC.style.borderColor = cpVal < 50 ? 'white' : 'black'; } }
        function updateColorFromPicker() { const hex = hsvToHex(cpHue, cpSat, cpVal); updateModalPreview(hex); }

        function toggleMobileMenu() { document.getElementById('mobile-tools-panel').classList.toggle('open'); }
        function closeMobileMenu() { document.getElementById('mobile-tools-panel').classList.remove('open'); }

        function setupSwipe() {
            const slider = document.getElementById('toolbarSlides');
            const dots = [document.getElementById('dot0'), document.getElementById('dot1'), document.getElementById('dot2')];
            if(!slider) return;
            slider.addEventListener('scroll', () => {
                const scrollLeft = slider.scrollLeft;
                const width = slider.clientWidth;
                const page = Math.round(scrollLeft / width);
                dots.forEach(d => d.classList.remove('active'));
                if(dots[page]) dots[page].classList.add('active');
            });
        }
        function setupZoomPan() {
            const ws = document.getElementById('workspace');
            ws.addEventListener('wheel', (e) => { if(currentTool !== 'hand') return; e.preventDefault(); const delta = e.deltaY > 0 ? 0.9 : 1.1; scale = Math.min(Math.max(0.5, scale * delta), 4); updateTransform(); });
            ws.addEventListener('pointerdown', (e) => { if(currentTool !== 'hand') return; if(e.target.closest('.zoom-controls')) return; panning = true; startX = e.clientX - translateX; startY = e.clientY - translateY; ws.setPointerCapture(e.pointerId); });
            ws.addEventListener('pointermove', (e) => { if(!panning || currentTool !== 'hand') return; e.preventDefault(); let nextX = e.clientX - startX; let nextY = e.clientY - startY; const limit = 300 * scale; translateX = Math.max(-limit, Math.min(limit, nextX)); translateY = Math.max(-limit, Math.min(limit, nextY)); updateTransform(); });
            ws.addEventListener('pointerup', (e) => { panning = false; ws.releasePointerCapture(e.pointerId); });
            ws.addEventListener('touchstart', (e) => { if(currentTool !== 'hand') return; if(e.touches.length === 2) { e.preventDefault(); initialPinchDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY); startScale = scale; } }, {passive: false});
            ws.addEventListener('touchmove', (e) => { if(currentTool !== 'hand') return; if(e.touches.length === 2) { e.preventDefault(); const currentDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY); if (initialPinchDist > 0) { const newScale = startScale * (currentDist / initialPinchDist); scale = Math.min(Math.max(0.5, newScale), 4); updateTransform(); } } }, {passive: false});
        }
        function updateTransform() { canvasWrapper.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`; }

        function setAppColor(val) {
            let hex = val;
            if (val.startsWith('rgb')) {
                try {
                    const rgb = val.match(/\d+/g);
                    if (rgb && rgb.length >= 3) {
                        hex = "#" + 
                            ("0" + parseInt(rgb[0]).toString(16)).slice(-2) + 
                            ("0" + parseInt(rgb[1]).toString(16)).slice(-2) + 
                            ("0" + parseInt(rgb[2]).toString(16)).slice(-2);
                    }
                } catch(e) { console.error("Erreur conversion couleur", e); return; }
            } else if (!val.startsWith('#')) {
                hex = '#' + val;
            }
            currentColor = hex.toUpperCase();
            const deskBtn = document.getElementById('deskColorBtn');
            const mobBtn = document.getElementById('mobColorBtn');
            const modalPreview = document.getElementById('modalColorPreview');
            const hexInput = document.getElementById('modalHexInput');
            if(deskBtn) deskBtn.style.backgroundColor = currentColor;
            if(mobBtn) mobBtn.style.backgroundColor = currentColor;
            if(modalPreview) modalPreview.style.backgroundColor = currentColor;
            if(hexInput) hexInput.value = currentColor.replace('#', '');
            if (!recentColors.includes(currentColor)) {
                recentColors.unshift(currentColor);
                if (recentColors.length > 12) recentColors.pop();
                updateRecentColorsUI();
            }
            const hsv = hexToHsv(currentColor);
            cpHue = hsv.h; cpSat = hsv.s; cpVal = hsv.v;
            updateCursors();
            updateSatArea(cpHue);
        }
		
        function getSnappedGridSize(rawVal) {
            let v = parseInt(rawVal);
            if (v <= 64) {
                return Math.round(v / 4) * 4;
            } else {
                return Math.round(v / 16) * 16;
            }
        }

        function setupEvents() {
            canvasWrapper.addEventListener('pointerdown', handleStart);
            window.addEventListener('pointermove', handleMove);
            window.addEventListener('pointerup', handleEnd);
            
            // GESTION DOUBLE CLIC POUR VALIDER LASSO
            canvasWrapper.addEventListener('dblclick', (e) => {
                if (isLassoActive && lassoAction) {
                    confirmSelectionAction();
                }
            });

            const handleGridInput = (e, textId) => {
                const snapped = getSnappedGridSize(e.target.value);
                updateGridText(snapped, textId);
            };

            const deskGridInput = document.getElementById('deskGridSize');
            if(deskGridInput) deskGridInput.oninput = (e) => handleGridInput(e, 'currentSize');
            
            const mobGridInput = document.getElementById('mobGridSize');
            if(mobGridInput) mobGridInput.oninput = (e) => handleGridInput(e, 'mobGridVal');

            document.getElementById('deskApplySize').onclick = () => {
                const raw = document.getElementById('deskGridSize').value;
                gridSize = getSnappedGridSize(raw);
                createGrid();
            };
            document.getElementById('mobApplyGrid').onclick = () => {
                const raw = document.getElementById('mobGridSize').value;
                gridSize = getSnappedGridSize(raw);
                createGrid();
                closeMobileMenu();
            };

            const deskBrushInput = document.getElementById('deskBrushSize');
            if(deskBrushInput) {
                deskBrushInput.oninput = (e) => {
                    brushSize = parseInt(e.target.value);
                    document.getElementById('deskBrushVal').textContent = brushSize;
                };
            }

            document.getElementById('imageUpload').addEventListener('change', handleImageUpload);
            document.getElementById('mobileImageUpload').addEventListener('change', handleImageUpload);

            const pixelBtn = document.getElementById('generatePixelArtBtn');
            if(pixelBtn) { pixelBtn.onclick = pixeliseImage; }

            const hexInput = document.getElementById('modalHexInput');
            if(hexInput) {
                hexInput.addEventListener('change', (e) => {
                    let val = e.target.value;
                    if(!val.startsWith('#')) val = '#' + val;
                    if(/^#[0-9A-F]{6}$/i.test(val)) setAppColor(val);
                });
            }
        }

        function setupShortcuts() {
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); }
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); }
                if(e.target.tagName === 'INPUT') return; 
                switch(e.key.toLowerCase()) {
                    case 'b': setTool('brush'); break;
                    case 'e': setTool('eraser'); break;
                    case 'f': setTool('fill'); break; 
                    case 'p': setTool('pipette'); break;
                    case 'l': setTool('lasso'); break;
                    case 'g': toggleGrid(); break;
                    case 'm': toggleSymmetry(); break; 
                    case 'h': setTool('hand'); break;
                    case 'enter': if(isLassoActive) confirmSelectionAction(); break;
                    case 'escape': if(isLassoActive) cancelSelection(); break;
                }
            });
        }		

        window.onload = () => {
            if (localStorage.getItem('pixelArtDarkMode') === 'true') { toggleDarkMode(true); }
            createGrid(); 
            setupEvents(); 
            setupZoomPan(); 
            updateToolUI();
            updateGridText(gridSize, 'currentSize'); 
            updateGridText(gridSize, 'mobGridVal');
            const mobBrush = document.getElementById('mobBrushSize');
            if(mobBrush) mobBrush.oninput = (e) => { brushSize = parseInt(e.target.value); document.getElementById('mobBrushVal').textContent = brushSize; };
            setupShortcuts(); 
            initCustomColorPicker(); 
            updateRecentColorsUI();
            setupSwipe();
            window.addEventListener('resize', createGrid);
        };
        
        window.setTool = setTool; window.toggleGrid = toggleGrid; window.toggleSymmetry = toggleSymmetry; window.toggleColorMenu = toggleColorMenu; window.toggleMobileMenu = toggleMobileMenu; window.closeMobileMenu = closeMobileMenu; window.undo = undo; window.redo = redo; window.createGrid = createGrid; window.toggleImageVisibility = toggleImageVisibility; window.removeImage = removeImage; window.pixeliseImage = pixeliseImage; window.exportCanvas = exportCanvas; window.showBaseColors = showBaseColors; window.showManualPicker = showManualPicker; window.selectBaseColor = selectBaseColor; window.pickColor = pickColor; window.openColorModal = openColorModal; window.updateSatSlider = updateSatSlider; window.updateValSlider = updateValSlider; window.toggleDarkMode = toggleDarkMode; window.moveCanvas = moveCanvas; window.setRefOpacity = setRefOpacity;
        // LASSO EXPORTS
        window.setSelectionAction = setSelectionAction; window.confirmSelectionAction = confirmSelectionAction; window.cancelSelection = cancelSelection;
    </script>
</body>
</html>
